"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/articles/page",{

/***/ "(app-pages-browser)/./lib/utils.ts":
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareIds: function() { return /* binding */ compareIds; },\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   formatTags: function() { return /* binding */ formatTags; },\n/* harmony export */   getCategoryImage: function() { return /* binding */ getCategoryImage; },\n/* harmony export */   getExcerpt: function() { return /* binding */ getExcerpt; },\n/* harmony export */   getGreeting: function() { return /* binding */ getGreeting; },\n/* harmony export */   getIdString: function() { return /* binding */ getIdString; },\n/* harmony export */   getRelativeTime: function() { return /* binding */ getRelativeTime; }\n/* harmony export */ });\n// Format date with optional time parameter\nconst formatDate = function(date) {\n    let includeTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const options = {\n        day: \"numeric\",\n        month: \"long\",\n        year: \"numeric\"\n    };\n    if (includeTime) {\n        options.hour = \"2-digit\";\n        options.minute = \"2-digit\";\n    }\n    return new Date(date).toLocaleDateString(\"id-ID\", options);\n};\n// Text excerpt utility\nfunction getExcerpt(content) {\n    let maxLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 150;\n    if (content.length <= maxLength) {\n        return content;\n    }\n    return content.substring(0, maxLength) + \"...\";\n}\n// Time-based greeting\nfunction getGreeting() {\n    const hours = new Date().getHours();\n    if (hours < 12) return \"Selamat Pagi\";\n    if (hours < 15) return \"Selamat Siang\";\n    if (hours < 19) return \"Selamat Sore\";\n    return \"Selamat Malam\";\n}\n// Gets a default image based on category\nfunction getCategoryImage(categoryId) {\n    switch(categoryId){\n        case \"planting\":\n            return \"https://images.unsplash.com/photo-1591857177580-dc82b9ac4e1e?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80\";\n        case \"fertilizer\":\n            return \"https://images.unsplash.com/photo-1584284867610-bf8330eeb4c7?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80\";\n        case \"pest\":\n            return \"https://images.unsplash.com/photo-1634138237256-84deb5d3d999?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80\";\n        case \"harvest\":\n            return \"https://images.unsplash.com/photo-1598512358669-ef567ef1d6cd?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80\";\n        default:\n            return \"https://images.unsplash.com/photo-1585059895524-72359e06133a?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80\";\n    }\n}\n// Format tag strings to array\nfunction formatTags(tagsString) {\n    return tagsString.split(\",\").map((tag)=>tag.trim()).filter((tag)=>tag !== \"\");\n}\n// Get relative time\nfunction getRelativeTime(date) {\n    const now = new Date();\n    const diffInMs = now.getTime() - new Date(date).getTime();\n    const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n    if (diffInDays === 0) {\n        return \"Hari ini\";\n    } else if (diffInDays === 1) {\n        return \"Kemarin\";\n    } else if (diffInDays < 7) {\n        return \"\".concat(diffInDays, \" hari yang lalu\");\n    } else if (diffInDays < 30) {\n        return \"\".concat(Math.floor(diffInDays / 7), \" minggu yang lalu\");\n    } else {\n        return formatDate(date);\n    }\n}\n// ID comparison utility for MongoDB/Mongoose IDs\nfunction compareIds(id1, id2) {\n    var _id1__id, _id1_id, _id2__id, _id2_id;\n    if (!id1 || !id2) return false;\n    // Convert to string if id is an object\n    const stringId1 = typeof id1 === \"object\" ? ((_id1__id = id1._id) === null || _id1__id === void 0 ? void 0 : _id1__id.toString()) || ((_id1_id = id1.id) === null || _id1_id === void 0 ? void 0 : _id1_id.toString()) : id1.toString();\n    const stringId2 = typeof id2 === \"object\" ? ((_id2__id = id2._id) === null || _id2__id === void 0 ? void 0 : _id2__id.toString()) || ((_id2_id = id2.id) === null || _id2_id === void 0 ? void 0 : _id2_id.toString()) : id2.toString();\n    return stringId1 === stringId2;\n}\n/**\r\n * Safely converts any type of ID (string, ObjectId, or object with _id or id) to a string\r\n * @param id - The ID to convert (can be string, ObjectId, or object)\r\n * @returns A string representation of the ID\r\n */ const getIdString = (id)=>{\n    if (!id) return \"\";\n    if (typeof id === \"string\") {\n        return id;\n    }\n    if (typeof id === \"object\") {\n        // Check for _id property (Mongoose common pattern)\n        if (id._id) {\n            return typeof id._id === \"object\" ? id._id.toString() : id._id;\n        }\n        // Check for id property (often used in serialized objects)\n        if (id.id) {\n            return id.id;\n        }\n        // If it's likely an ObjectId itself\n        if (id.toString && typeof id.toString === \"function\") {\n            return id.toString();\n        }\n    }\n    // Fallback - return an empty string if no valid ID format is found\n    return \"\";\n};\n// Tambahkan fungsi ini di file yang sama (sebagai helper lokal)\nconst isSameId = (id1, id2)=>{\n    // Jika keduanya tidak ada, return false\n    if (!id1 || !id2) return false;\n    // Convert ke string untuk keamanan perbandingan\n    const str1 = typeof id1 === \"object\" ? id1.toString ? id1.toString() : (id1.id || id1._id || \"\").toString() : id1.toString();\n    const str2 = typeof id2 === \"object\" ? id2.toString ? id2.toString() : (id2.id || id2._id || \"\").toString() : id2.toString();\n    return str1 === str2;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bnRlbnQiOlsiLy8gRm9ybWF0IGRhdGUgd2l0aCBvcHRpb25hbCB0aW1lIHBhcmFtZXRlclxyXG5leHBvcnQgY29uc3QgZm9ybWF0RGF0ZSA9IChkYXRlOiBEYXRlIHwgc3RyaW5nLCBpbmNsdWRlVGltZSA9IGZhbHNlKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBvcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcclxuICAgIGRheTogJ251bWVyaWMnLFxyXG4gICAgbW9udGg6ICdsb25nJyxcclxuICAgIHllYXI6ICdudW1lcmljJyxcclxuICB9O1xyXG4gIFxyXG4gIGlmIChpbmNsdWRlVGltZSkge1xyXG4gICAgb3B0aW9ucy5ob3VyID0gJzItZGlnaXQnO1xyXG4gICAgb3B0aW9ucy5taW51dGUgPSAnMi1kaWdpdCc7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBuZXcgRGF0ZShkYXRlKS50b0xvY2FsZURhdGVTdHJpbmcoJ2lkLUlEJywgb3B0aW9ucyk7XHJcbn07XHJcbiAgXHJcbiAgLy8gVGV4dCBleGNlcnB0IHV0aWxpdHlcclxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RXhjZXJwdChjb250ZW50OiBzdHJpbmcsIG1heExlbmd0aCA9IDE1MCk6IHN0cmluZyB7XHJcbiAgICBpZiAoY29udGVudC5sZW5ndGggPD0gbWF4TGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gY29udGVudC5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoKSArICcuLi4nO1xyXG4gIH1cclxuICBcclxuICAvLyBUaW1lLWJhc2VkIGdyZWV0aW5nXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEdyZWV0aW5nKCk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBob3VycyA9IG5ldyBEYXRlKCkuZ2V0SG91cnMoKTtcclxuICAgIGlmIChob3VycyA8IDEyKSByZXR1cm4gXCJTZWxhbWF0IFBhZ2lcIjtcclxuICAgIGlmIChob3VycyA8IDE1KSByZXR1cm4gXCJTZWxhbWF0IFNpYW5nXCI7XHJcbiAgICBpZiAoaG91cnMgPCAxOSkgcmV0dXJuIFwiU2VsYW1hdCBTb3JlXCI7XHJcbiAgICByZXR1cm4gXCJTZWxhbWF0IE1hbGFtXCI7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEdldHMgYSBkZWZhdWx0IGltYWdlIGJhc2VkIG9uIGNhdGVnb3J5XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGdldENhdGVnb3J5SW1hZ2UoY2F0ZWdvcnlJZDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIHN3aXRjaCAoY2F0ZWdvcnlJZCkge1xyXG4gICAgICBjYXNlICdwbGFudGluZyc6XHJcbiAgICAgICAgcmV0dXJuICdodHRwczovL2ltYWdlcy51bnNwbGFzaC5jb20vcGhvdG8tMTU5MTg1NzE3NzU4MC1kYzgyYjlhYzRlMWU/aXhsaWI9cmItNC4wLjMmYXV0bz1mb3JtYXQmZml0PWNyb3Amdz04MDAmcT04MCc7XHJcbiAgICAgIGNhc2UgJ2ZlcnRpbGl6ZXInOlxyXG4gICAgICAgIHJldHVybiAnaHR0cHM6Ly9pbWFnZXMudW5zcGxhc2guY29tL3Bob3RvLTE1ODQyODQ4Njc2MTAtYmY4MzMwZWViNGM3P2l4bGliPXJiLTQuMC4zJmF1dG89Zm9ybWF0JmZpdD1jcm9wJnc9ODAwJnE9ODAnO1xyXG4gICAgICBjYXNlICdwZXN0JzpcclxuICAgICAgICByZXR1cm4gJ2h0dHBzOi8vaW1hZ2VzLnVuc3BsYXNoLmNvbS9waG90by0xNjM0MTM4MjM3MjU2LTg0ZGViNWQzZDk5OT9peGxpYj1yYi00LjAuMyZhdXRvPWZvcm1hdCZmaXQ9Y3JvcCZ3PTgwMCZxPTgwJztcclxuICAgICAgY2FzZSAnaGFydmVzdCc6XHJcbiAgICAgICAgcmV0dXJuICdodHRwczovL2ltYWdlcy51bnNwbGFzaC5jb20vcGhvdG8tMTU5ODUxMjM1ODY2OS1lZjU2N2VmMWQ2Y2Q/aXhsaWI9cmItNC4wLjMmYXV0bz1mb3JtYXQmZml0PWNyb3Amdz04MDAmcT04MCc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuICdodHRwczovL2ltYWdlcy51bnNwbGFzaC5jb20vcGhvdG8tMTU4NTA1OTg5NTUyNC03MjM1OWUwNjEzM2E/aXhsaWI9cmItNC4wLjMmYXV0bz1mb3JtYXQmZml0PWNyb3Amdz04MDAmcT04MCc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEZvcm1hdCB0YWcgc3RyaW5ncyB0byBhcnJheVxyXG4gIGV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUYWdzKHRhZ3NTdHJpbmc6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiB0YWdzU3RyaW5nXHJcbiAgICAgIC5zcGxpdCgnLCcpXHJcbiAgICAgIC5tYXAodGFnID0+IHRhZy50cmltKCkpXHJcbiAgICAgIC5maWx0ZXIodGFnID0+IHRhZyAhPT0gJycpO1xyXG4gIH1cclxuICBcclxuICAvLyBHZXQgcmVsYXRpdmUgdGltZVxyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVRpbWUoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3QgZGlmZkluTXMgPSBub3cuZ2V0VGltZSgpIC0gbmV3IERhdGUoZGF0ZSkuZ2V0VGltZSgpO1xyXG4gICAgY29uc3QgZGlmZkluRGF5cyA9IE1hdGguZmxvb3IoZGlmZkluTXMgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xyXG4gICAgXHJcbiAgICBpZiAoZGlmZkluRGF5cyA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJ0hhcmkgaW5pJztcclxuICAgIH0gZWxzZSBpZiAoZGlmZkluRGF5cyA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gJ0tlbWFyaW4nO1xyXG4gICAgfSBlbHNlIGlmIChkaWZmSW5EYXlzIDwgNykge1xyXG4gICAgICByZXR1cm4gYCR7ZGlmZkluRGF5c30gaGFyaSB5YW5nIGxhbHVgO1xyXG4gICAgfSBlbHNlIGlmIChkaWZmSW5EYXlzIDwgMzApIHtcclxuICAgICAgcmV0dXJuIGAke01hdGguZmxvb3IoZGlmZkluRGF5cyAvIDcpfSBtaW5nZ3UgeWFuZyBsYWx1YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmb3JtYXREYXRlKGRhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbi8vIElEIGNvbXBhcmlzb24gdXRpbGl0eSBmb3IgTW9uZ29EQi9Nb25nb29zZSBJRHNcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVJZHMoaWQxOiBhbnksIGlkMjogYW55KTogYm9vbGVhbiB7XHJcbiAgaWYgKCFpZDEgfHwgIWlkMikgcmV0dXJuIGZhbHNlO1xyXG4gIFxyXG4gIC8vIENvbnZlcnQgdG8gc3RyaW5nIGlmIGlkIGlzIGFuIG9iamVjdFxyXG4gIGNvbnN0IHN0cmluZ0lkMSA9IHR5cGVvZiBpZDEgPT09ICdvYmplY3QnID8gXHJcbiAgICAoaWQxLl9pZD8udG9TdHJpbmcoKSB8fCBpZDEuaWQ/LnRvU3RyaW5nKCkpIDogXHJcbiAgICBpZDEudG9TdHJpbmcoKTtcclxuICAgIFxyXG4gIGNvbnN0IHN0cmluZ0lkMiA9IHR5cGVvZiBpZDIgPT09ICdvYmplY3QnID8gXHJcbiAgICAoaWQyLl9pZD8udG9TdHJpbmcoKSB8fCBpZDIuaWQ/LnRvU3RyaW5nKCkpIDogXHJcbiAgICBpZDIudG9TdHJpbmcoKTtcclxuICAgIFxyXG4gIHJldHVybiBzdHJpbmdJZDEgPT09IHN0cmluZ0lkMjtcclxufVxyXG5cclxuLy8gQWRkIHRoaXMgdXRpbGl0eSBmdW5jdGlvbiB0byBzYWZlbHkgY29udmVydCBhbnkgb2JqZWN0IElEIHRvIHN0cmluZyBmb3JtYXRcclxuXHJcbmltcG9ydCB7IE9iamVjdElkIH0gZnJvbSAnbW9uZ29vc2UnO1xyXG5cclxuLyoqXHJcbiAqIFNhZmVseSBjb252ZXJ0cyBhbnkgdHlwZSBvZiBJRCAoc3RyaW5nLCBPYmplY3RJZCwgb3Igb2JqZWN0IHdpdGggX2lkIG9yIGlkKSB0byBhIHN0cmluZ1xyXG4gKiBAcGFyYW0gaWQgLSBUaGUgSUQgdG8gY29udmVydCAoY2FuIGJlIHN0cmluZywgT2JqZWN0SWQsIG9yIG9iamVjdClcclxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIElEXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0SWRTdHJpbmcgPSAoaWQ6IHN0cmluZyB8IE9iamVjdElkIHwgeyBfaWQ/OiBPYmplY3RJZCB8IHN0cmluZywgaWQ/OiBzdHJpbmcgfSB8IGFueSk6IHN0cmluZyA9PiB7XHJcbiAgaWYgKCFpZCkgcmV0dXJuICcnO1xyXG4gIFxyXG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gaWQ7XHJcbiAgfVxyXG4gIFxyXG4gIGlmICh0eXBlb2YgaWQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAvLyBDaGVjayBmb3IgX2lkIHByb3BlcnR5IChNb25nb29zZSBjb21tb24gcGF0dGVybilcclxuICAgIGlmIChpZC5faWQpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBpZC5faWQgPT09ICdvYmplY3QnID8gaWQuX2lkLnRvU3RyaW5nKCkgOiBpZC5faWQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGZvciBpZCBwcm9wZXJ0eSAob2Z0ZW4gdXNlZCBpbiBzZXJpYWxpemVkIG9iamVjdHMpXHJcbiAgICBpZiAoaWQuaWQpIHtcclxuICAgICAgcmV0dXJuIGlkLmlkO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJZiBpdCdzIGxpa2VseSBhbiBPYmplY3RJZCBpdHNlbGZcclxuICAgIGlmIChpZC50b1N0cmluZyAmJiB0eXBlb2YgaWQudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGlkLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEZhbGxiYWNrIC0gcmV0dXJuIGFuIGVtcHR5IHN0cmluZyBpZiBubyB2YWxpZCBJRCBmb3JtYXQgaXMgZm91bmRcclxuICByZXR1cm4gJyc7XHJcbn07XHJcblxyXG4vLyBUYW1iYWhrYW4gZnVuZ3NpIGluaSBkaSBmaWxlIHlhbmcgc2FtYSAoc2ViYWdhaSBoZWxwZXIgbG9rYWwpXHJcbmNvbnN0IGlzU2FtZUlkID0gKGlkMTogYW55LCBpZDI6IGFueSk6IGJvb2xlYW4gPT4ge1xyXG4gIC8vIEppa2Ega2VkdWFueWEgdGlkYWsgYWRhLCByZXR1cm4gZmFsc2VcclxuICBpZiAoIWlkMSB8fCAhaWQyKSByZXR1cm4gZmFsc2U7XHJcbiAgXHJcbiAgLy8gQ29udmVydCBrZSBzdHJpbmcgdW50dWsga2VhbWFuYW4gcGVyYmFuZGluZ2FuXHJcbiAgY29uc3Qgc3RyMSA9IHR5cGVvZiBpZDEgPT09ICdvYmplY3QnID8gXHJcbiAgICAoaWQxLnRvU3RyaW5nID8gaWQxLnRvU3RyaW5nKCkgOiAoaWQxLmlkIHx8IGlkMS5faWQgfHwgJycpLnRvU3RyaW5nKCkpIDogXHJcbiAgICBpZDEudG9TdHJpbmcoKTtcclxuICBcclxuICBjb25zdCBzdHIyID0gdHlwZW9mIGlkMiA9PT0gJ29iamVjdCcgPyBcclxuICAgIChpZDIudG9TdHJpbmcgPyBpZDIudG9TdHJpbmcoKSA6IChpZDIuaWQgfHwgaWQyLl9pZCB8fCAnJykudG9TdHJpbmcoKSkgOiBcclxuICAgIGlkMi50b1N0cmluZygpO1xyXG4gIFxyXG4gIHJldHVybiBzdHIxID09PSBzdHIyO1xyXG59OyJdLCJuYW1lcyI6WyJmb3JtYXREYXRlIiwiZGF0ZSIsImluY2x1ZGVUaW1lIiwib3B0aW9ucyIsImRheSIsIm1vbnRoIiwieWVhciIsImhvdXIiLCJtaW51dGUiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiZ2V0RXhjZXJwdCIsImNvbnRlbnQiLCJtYXhMZW5ndGgiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJnZXRHcmVldGluZyIsImhvdXJzIiwiZ2V0SG91cnMiLCJnZXRDYXRlZ29yeUltYWdlIiwiY2F0ZWdvcnlJZCIsImZvcm1hdFRhZ3MiLCJ0YWdzU3RyaW5nIiwic3BsaXQiLCJtYXAiLCJ0YWciLCJ0cmltIiwiZmlsdGVyIiwiZ2V0UmVsYXRpdmVUaW1lIiwibm93IiwiZGlmZkluTXMiLCJnZXRUaW1lIiwiZGlmZkluRGF5cyIsIk1hdGgiLCJmbG9vciIsImNvbXBhcmVJZHMiLCJpZDEiLCJpZDIiLCJzdHJpbmdJZDEiLCJfaWQiLCJ0b1N0cmluZyIsImlkIiwic3RyaW5nSWQyIiwiZ2V0SWRTdHJpbmciLCJpc1NhbWVJZCIsInN0cjEiLCJzdHIyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils.ts\n"));

/***/ })

});